<!DOCTYPE html>
<html lang="kr">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Home - My first website.</title>
    <link href="styles.css" rel="stylesheet" />
    <style>
      /* * {

      } */
      h1 {
        color: green;
        font-style: italic;
      }
    </style>
  </head>
  <body>
    <header>
      <!-- 가급적 semantic text ="header, main, p, footer etc." - content sectioning -->
      <h1>The Yeon Times</h1>
    </header>
    <main>
      <p>CSS</p>
      <h3>
        CSS에서, block(대부분, div)이 아닌 inline(span)은 <br />
        1. 높이와 너비가 없다. <br />
        2. 위, 아래의 마진값이 적용 안 된다.(좌우만 존재) <br />
      </h3>
      <h3>
        inline-block 이라고 하는 display가 있다. <br />
        <li>
          사방에 마진을 가질 수 있으며, 높이와 너비도 있는데 줄바꿈은 없다. (옆에 다른 요소가 올 수 있다.)<br />
          그러나 인라인 블럭은 쓰레기다. 마진이 아닌 빈 공간이 있으며, 정해진 형식도 없다. 반응형도 적용되지 않음
        </li>
      </h3>
      <h2>The best display. The best block. FLEX.</h2>
      <p>
        <strong>플렉스박스, 주의점 세 가지.</strong><br /> <!-- 주축(main axis_가로축, justify-content)과 교차축(cross axis_세로축, align-items) 검색 예시 css flexbox main axis cross axis) -->
        the first, 자식 엘리먼트에 아무 것도 적으면 안 된다. 예시로 body 안에 있는 div에 플렉스박스 사용을 하려면, body에 display: flex;를 적용해야 한다.<br />
        <h5>flex를 쓰는 body에는 justify-content: (center, flex-end, space-between etc.);를 사용할 수 있게 된다.</h5>
        <h5>주축(가로축_수평)의 저스티파이 컨텐트와 달리 교차축(세로축_수직)의 align-items: (flex-end, stretch etc.);라는 프로퍼티 또한 사용 가능하다_보통 height와 같이 사용하는데 vh(viewport height)로 사용한다.</h5>
        the second, justify-content<br />
        the third, align-items<br />
        * flex-direction: (row는 default, column은 주축과 교차축을 바꿈_메인이 수직);<br />
        * flex-wrap: nowrap;은 모든 요소를 같은 줄에 있게 함, wrap은 요소가 반응형으로 내려감(column, column-reverse, row-reverse, wrap-reverse etc.).
      </p>
      <br />
      <br />
      <p>
        <strong>Position</strong><br />
        position: fixed; -> height: 1000vh;와 함께 적용. -> 스크롤 이동을 하여도 화면 해당 위치에 보임.(사이드 바, 반응형, 인터랙티브 웹 등)<br />
        일반적으로 처음 위치에서 고정하지만, top값을 수정한다거나 하여 위의 블럭을 침범하거나 할 경우, 다른 레이어로써 취급되는 듯이 위에 덧씌인다.<br />

      </p>
        <br /><strong>Position: static;</strong><br />
        포지션의 디폴트값, 맨 처음 위치로 설정된다.
        <br /><strong>Position: relative;</strong><br />
        top, bottom, left, right로 해당 위치를 기준으로 이동을 할 수 있다.(px, 음수 값 포함) <strong>*일반적으로 position: absolute;가 걸린 태그의 부모 역할을 한다.</strong>
        <br /><strong>Position: absolute;</strong><br />
        body 전체(해당 div의 부모태그 기준)에서의 극한으로 이동한다. <strong>*부모태그에 position: relative;가 걸려 있으면, 해당 포지션에서 박스 내부에서 움직임.</strong><br />
        
      <li>
        CSS에서 ex) height 는 not only 'px', but 'vh(viewport_screen_화면 퍼센티지_반응형)'
      </li>
      <li>
        클래스는 여러 개를 동시에 선택할 수 있고, 여러 개를 동시에 가질 수 있다.<br />
        "클래스이름 클래스이름"식으로 공백 넣어서 설정
      </li>
      <li>
        선택자 설정할 때, 태그네임에 콜론을 붙이면 많은 옵션이 나온다. 굳이 클래스나 아이디로 지정하지 않아도 조건을 넣어 선택할 수 있다.<br />
        ex) div:last-child {}, span:nth-child(n_숫자, 2n_짝수, 2n+1_홀수 even_짝수, odd_홀수 etc.) {} etc. 선택자를 설정하는 것보다 좋은 방법이다.
      </li>
      <li>
        (pseudo selector) 선택자를 설정할 때, p 태그 안에 있는 span 태그를 선택하려면 p span_(부모태그 선택태그)으로 처리하면 된다. *부모태그는 여러 개 쓸 수 있다. *부모의 부모태그에서 바로 자식 태그로 들어가도 적용된다.(주의) (태그 둘 다 적용할 시, 반점을 사용하여 p, span이다.)<br />
        div 바로 다음 자식태그만을 설정한다면, div > span {}으로 작성하면 된다.<br />
        /p> 태그를 닫은 후 바로 뒤에 오는 태그(span)만을 설정하고 싶은 경우, p + span {}으로 작성하면 된다.
      </li>
      <li>(pseudo element)<strong>combinator_ ~, >, &, * 등</strong><br />
        p태그를 닫고서, 다른 태그 너머의 형제태그 span을 선택할 경우, p ~ span {} 어쨌든 형제태그여야 한다. _먼 형제의 태그를 선택했다고 볼 수 있다.<br />
      </li>
      <li>
        required가 들어간 태그(input)를 선택하는 법, input:required {} 이다. input:optional로 쓰면 뭔가(attribute) 들어간 인풋 태그는 전부 선택된다.
        input type="password"를 선택하는 법, input[type="password"] {}이다. 마찬가지로 input[placeholder="username"] {} 등의 선택도 가능하다.
      </li>
      <li>
        input type="text" placeholder="First name"<br />
        input type="text" placeholder="Last name"<br />
        에서 두 개 전부를 선택하려면, ~(exactly)을 사용하면 된다. input[placeholder~="name"] {} 이다.<br />
        *주의사항, ~은 앞뒤 공백이 있는, 오로지 해당 단어를 단독으로 가지는 것에만 선택이 되고(user name = ok, username = x)<br />
        *(contains?)을 포함하면 해당 내용을 가지는 공백과 상관 없이 모든 것을 선택 (user name = ok, username = ok), input[placeholder*="name"] {} <br />
        a[href$=".org"] {}, 달러 표시(end, ending)는 ~로 끝나는 모든 태그를 뜻한다. // <!-- search [css attribute selectors] element[attr="value"] --><br />
        달러 표시 대신 ^를 사용하면, 시작 부분을 선택한다.
      </li>
      <li>
        개발자 도구에서 볼 수 있는 가장 중요한 선택자(selector)는 states다. :active, :focus etc.<br />
        ex) button:active {background-color: tomato;} (버튼의, 버튼을 눌렀을 때 씌워지는 블럭의 색을 변경할 수 있다.) focus는 선택된 것의~ focus-within은 해당 태그의 자식 태그가 선택되었을 때~<br />
          button:hover {background-color: tomato;} (버튼에 마우스를 올렸을 때의 버튼 배경색을 변경할 수 있다.)_form:hover input {}이 되면, 인풋의 부모태그(폼)가 호버링 됐을 때, 인풋이 바뀐다.<br />
          링크에만 적용할 수 있는 visited는, 누른 적이 있을 때 color 등으로 문자색을 변경하거나 할 수 있다. a:visited {}
      </li>
      <li>
        만일, placeholder 자체를 변경하고 싶다면, input::placeholder {}로 변경하면 된다. 그냥 인풋 변경을 할 시에는 적은 내용이 변경되고, 플레이스홀더 자체를 변경하면 인풋이 아닌 플레이스홀더 자체의 밸류값이 변경된다.<br />
        p::selection {}는 해당 p의 내용을 선택(박스로 씌울 때)할 때 상태가 변한다.<br />
        추가로 first-letter를 사용하면, 영문 편지체나 책의 첫 글자처럼, 첫 글자만 수정이 가능하다.
      </li>
      <li>
        color<br />
        컬러코드, 복사하여 사용 가능 color: #fcce00; 브라우저에서 컬러코드 복사해오기_**크롬 확장프로그램의 color picker 쓰면 됨<br>
        RGB 값 -> color: rgb(000, 000, 000); color: rgba(000, 000, 000, 000); a는 알파, 투명도를 뜻함(opacity)<br>
        style 값에 :root {--main-color: #fcce00;} 을 쓰면, 해당 컬러코드를 메인 색으로 사용 가능, 다른 컬러 값에 color: var(--main-color);를 넣으면 됨. 루트값은 문서 전체를 뜻함, 변수 이름은 dash 2개, dash 1개에 변수 이름을 붙여 지어야 함(또 공백이 있으면 대쉬).<br>
        응용하면, :root {--default-border: 1px solid var(--main-color);} 이런 것도 가능. a {border: var(--default-border);}<br>
        CSS의 변수를 custom property 라고 함. Search [CSS custom property]
      </li>
    </main>
    <footer>
      <!-- 꼬릿말 -->
      &copy; 2022 S.K.
      <!-- copyright -->
    </footer>
  </body>
</html>
